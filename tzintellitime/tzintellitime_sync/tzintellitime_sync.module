<?php

define('TZINTELLITIME_SYNC_USERS_PER_RUN', variable_get('tzintellitime_sync_users_per_run', 100));
define('TZINTELLITIME_SYNC_ABSENCE_PARENT_JOB_ID', 'TimeZynkIntellitimeSyncAbsenceParent');

/**
 * Implementation of hook_user, annotates the user object with additional synchronization information
 */
function tzintellitime_sync_user($op, &$edit, &$account, $category = NULL) {
  switch($op) {
    case 'insert':
      if(isset($edit['intellitime_last_sync'])) {
        drupal_write_record('tzintellitime_sync', $edit);
      }
      $edit['intellitime_last_sync'] = NULL;
      $edit['intellitime_active'] = NULL;
      break;

    case 'load':
      $fields = db_fetch_array(db_query('SELECT * FROM {tzintellitime_sync} WHERE uid = %d', $account->uid));
      if($fields) {
        foreach($fields as $field => $value) {
          $account->$field = $value;
        }
      }
      break;

    case 'update':
      if(isset($edit['intellitime_last_sync']) || isset($edit['intellitime_active'])) {
        drupal_write_record('tzintellitime_sync', $edit, 'uid');
      }
      $edit['intellitime_last_sync'] = NULL;
      $edit['intellitime_active'] = NULL;
      break;
  }
}

/**
 * Schedule the user with specified uid for synchronizations as soon as possible.
 * @param int $uid user id
 */
function tzintellitime_sync_schedule_user($uid) {
  if($uid) {
    $entry = array('uid' => $uid, 'intellitime_active' => 1);
    if(db_result(db_query('SELECT COUNT(*) FROM {tzintellitime_sync} WHERE uid = %d', $uid))) {
      drupal_write_record('tzintellitime_sync', $entry, 'uid');
    } else {
      drupal_write_record('tzintellitime_sync', $entry);
    }
    return TRUE;
  }
  return FALSE;
}

function tzintellitime_sync_unschedule_user($uid) {
  if($uid) {
    db_query('UPDATE {tzintellitime_sync} SET intellitime_active = 0 WHERE uid = %d', $uid);
    return TRUE;
  }
  return FALSE;
}

function tzintellitime_sync_synchronize_users() {
  tzintellitime_include_classes();
  $result = db_query_range('SELECT * FROM {tzintellitime_sync} WHERE intellitime_active = 1 ORDER BY intellitime_last_sync ASC', 0, TZINTELLITIME_SYNC_USERS_PER_RUN);
  while($elem = db_fetch_object($result)) {
    // Load user account
    $account = user_load(array('uid' => $elem->uid));
    if(!$account || !tzintellitime_is_authenticated($account)) {
      // User not found or not intellitime user
      tzintellitime_sync_unschedule_user($elem->uid);
      continue;
    }

    $ctrlr = new TZIntellitimeSyncController($account);

    $result = $ctrlr->synchronize();

    if(TZIntellitimeSyncController::SYNC_OK === $result) {
      $elem->intellitime_last_sync = time();
      drupal_write_record('tzintellitime_sync', $elem, 'uid');
    } elseif(TZIntellitimeSyncController::AUTH_FAILURE === $result) {
      // Failed authentication, unschedule user
      TZIntellitimeBot::destroy_session_data($account->intellitime_session_data);
      user_save($account, array('intellitime_session_data' => NULL, 'intellitime_active' => 0));
    } else {
      // Hopefully a temporary failure, log
      watchdog('tzintellitime', 'Failed to synchronize user !name (!uid), last sync !min minutes ago',
               array('!name' => $account->name, '!uid' => $account->uid, '!min' => (time() - $elem->intellitime_last_sync)/60),
               WATCHDOG_WARNING);
    }
  }
}

class TZIntellitimeSyncController {
  const SYNC_OK = 0;
  const PENDING = 1;
  const NETWORK_FAILURE = 2;
  const AUTH_FAILURE = 3;

  private $account = NULL;
  private $bot = NULL;
  private $week_status = array();
  private $data = array(
   'assignments' => array(),
   'reports' => array(),
  );

  function __construct($account) {
    // Setup bot and fetch this weeks assignments
    $this->account = $account;
    $this->bot = new TZIntellitimeBot(TZINTELLITIME_BASE_URL, $account->intellitime_session_data);
  }

  /**
   * Synchronize with intellitime.
   * @return SYNC_OK on success, and NETWORK_FAILURE or AUTH_FAILURE respectively on error.
   */
  function synchronize() {
    // Always sync this week
    $this->set_week_status(time(), TZIntellitimeSyncController::PENDING);

    $this->add_unlocked_weeks();
    $this->send_updated_reports();
    $this->load_pending_weeks();

    // Check if we could sync anything
    if(array_search(TZIntellitimeSyncController::NETWORK_FAILURE, $this->week_status)) {
      // Failed to load week because of network error, give up for now
      return TZIntellitimeSyncController::NETWORK_FAILURE;
    } else if(array_search(TZIntellitimeSyncController::AUTH_FAILURE, $this->week_status)) {
      // Authentication failed
      return TZIntellitimeSyncController::AUTH_FAILURE;
    }

    // All weeks fetched, convert data
    $jobmap = $this->convert_assignments();
    $seen_reports = $this->convert_reports($jobmap);

    // Mark removed reports
    $this->mark_removed_reports($seen_reports);


    return TZIntellitimeSyncController::SYNC_OK;
  }

  /**
   * Get a week-unique key for this timestamp. Suitable for grouping
   * several requests by week. Current format is <WeekYear>W<Week> which
   * is chosen because it can be parsed straight up by strtotime.
   * @param int $timestamp
   * @return string YYYY'W'WW
   */
  function week_key($timestamp) {
    return date('o\WW', $timestamp);
  }

  function set_week_status($timestamp, $status) {
    $this->week_status[$this->week_key($timestamp)] = $status;
  }

  /**
   * Add weeks where we have unlocked reports as pending for sync.
   */
  function add_unlocked_weeks() {
    $result = db_query('SELECT begintime FROM {tzreport} WHERE assignedto = %d AND flags <= %d', $this->account->uid, TZFlags::REPORTED);
    while($time = db_result($result)) {
      $this->set_week_status($time, TZIntellitimeSyncController::PENDING);
    }
  }

  /**
   * Load pending weeks
   */
  function load_pending_weeks() {
    while($week = array_search(TZIntellitimeSyncController::PENDING, $this->week_status)) {
      $data = $this->bot->load_week(strtotime($week));
      $this->process_week_data($week, $data);
    }
  }

  /**
   * Process the week data returned from TZIntellitimeBot.
   * It will go through all assignments and reports and merge them into
   * the $this->data field. It also checks for new unfinished weeks and
   * adds them as pending.
   * @param string $week current week as formatted by week_key()
   * @param $data data from TZIntellitimeBot
   */
  function process_week_data($week, $data) {
    if($data && isset($data['reports']) && isset($data['assignments'])) {
      foreach($data['assignments'] as $assignment) {
        $this->data['assignments'][$assignment->id] = $assignment;
      }
      foreach($data['reports'] as $report) {
        $this->data['reports'][$report->get_intellitime_id($this->account->uid)] = $report;
      }

      // Check for extra weeks that needs to be synchronized
      foreach($data['unfinished_weeks'] as $weekdate) {
        $weekstr = $this->week_key($weekdate);
        if(!isset($this->week_status[$weekstr])) {
          $this->week_status[$weekstr] = TZIntellitimeSyncController::PENDING;
        }
      }

      $this->week_status[$week] = TZIntellitimeSyncController::SYNC_OK;
    } elseif(FALSE === $data) {
      $this->week_status[$week] = TZIntellitimeSyncController::NETWORK_FAILURE;
    } else {
      $this->week_status[$week] = TZIntellitimeSyncController::AUTH_FAILURE;
    }
  }

  /**
   * Convert all TZIntellitimeAssignments in $this->data to tzjobs.
   * @return Array map from <job key> => <job node id> for use with convert_reports
   */
  function convert_assignments() {
    $jobmap = array();

    // Create default absence parent job if needed
    $absence_assignment = new TZIntellitimeAssignment();
    $absence_assignment->id = TZINTELLITIME_SYNC_ABSENCE_PARENT_JOB_ID;
    $absence_assignment->title = t('Absence');
    $absence_node = $this->create_job($absence_assignment);

    foreach($this->data['assignments'] as $tzassignment) {
      $parentid = 0;
      // Place absence type assignments as children of the absence parent job
      if ($tzassignment->type == TZIntellitimeAssignment::TYPE_ABSENCE) {
        $parentid = $absence_node->nid;
      }
      $job = $this->create_job($tzassignment, $parentid);
      $jobmap[$tzassignment->report_key] = $job->nid;
    }
    return $jobmap;
  }

  /**
   * Convert all TZIntellitimeReports in $this->data to tzreports.
   * @param Array $jobmap jobmap from convert_assignments()
   * @return Array array of tzreport->nid for all processed reports.
   */
  function convert_reports($jobmap) {
    $seen_reports = array();
    foreach($this->data['reports'] as $itreport) {
      $tzreport = $this->create_report($itreport, $jobmap);
      $seen_reports[] = $tzreport->nid;
    }
    return $seen_reports;
  }

  /**
   * Mark reports as deleted if they are in our synchronized date range but was not
   * found on the server.
   * @param Array $seen_reports lists of all reports found during synchronization
   */
  function mark_removed_reports($seen_reports) {
    $seenquery = array();
    foreach($seen_reports as $nid) {
      $seenquery[] = 'n.nid != %d';
    }
    $seenquery = implode(' AND ', $seenquery);
    foreach(array_keys($this->week_status) as $week) {
      $date = getdate(strtotime($week));
      // Find beginning and end of week
      $begin = mktime(0, 0, 0, $date['mon'], $date['mday'], $date['year']);
      $end = mktime(0, 0, 0, $date['mon'], $date['mday']+7, $date['year']);
      // Select reports in range
      $queryargs = array(time(), TZFlags::DELETED, TZFlags::DELETED, $begin, $end, $this->account->uid);
      $queryargs = array_merge($queryargs, $seen_reports);
      // Update tzreport->flags to TZFlags::DELETED if the node ID is not found in the $seen_reports array
      $query = 'UPDATE {node} n INNER JOIN {tzreport} t ON n.nid = t.nid SET changed = %d, flags = %d WHERE flags != %d AND begintime >= %d AND begintime < %d AND assignedto = %d AND ' . $seenquery;
      db_query($query, $queryargs);
      watchdog('zynk', 'updated !rows deleted rows', array('!rows' => db_affected_rows()));
    }
  }

  /**
   * Find reports that have been updated since last sync and send them to the server
   */
  function send_updated_reports() {
    // Find reports that need update
    $result = db_query('SELECT * FROM {node} n INNER JOIN {tzreport} t ON n.nid = t.nid INNER JOIN {tzintellitime} i ON n.nid = i.nid WHERE n.changed > %d AND t.assignedto = %d',
                       $this->account->intellitime_last_sync, $this->account->uid);
    while($tzreport = db_fetch_object($result)) {
      watchdog('tzintellitime', 'Sending report with nid !nid and itid !itid to week !week', array('!nid' => $tzreport->nid, '!itid' => $tzreport->intellitime_id, '!week' => date('o\WW', $tzreport->begintime)));
      // Convert and post report
      $itreport = new TZIntellitimeReport($tzreport);
      $data = $this->bot->update_report($itreport);
      $this->process_week_data($this->week_key($tzreport->begintime), $data);
    }
  }

  /**
   * Create or update a tzreport from a TZIntellitimeReport
   * @param TZIntellitimeReport $intelli_report
   * @param Array $job_map as returned from convert_assignments
   */
  function create_report($intelli_report, $job_map = array()) {
    // Try to fetch previous report
    $tzreport = tzintellitime_node_load_by_intellitime_id($intelli_report->get_intellitime_id($this->account->uid));
    $tzreport = $intelli_report->convert_to_tzreport($this->account, $tzreport);

    // Map job to report by searching for matching title
    if (isset($job_map[$intelli_report->title])) {
      $tzreport->jobid = $job_map[$intelli_report->title];
    } elseif(!isset($tzreport->jobid) || !$tzreport->jobid) {
      // Should not be able to create a report without a valid job.
      watchdog('tzintellitime', 'Tried to create tzreport without valid jobid', array(), WATCHDOG_WARNING);
      return NULL;
    }

    return $this->store_node($tzreport);
  }

  /**
   * Create or update a tzjob from a TZIntellitimeAssignment
   * @param TZIntellitimeAssignment $intelli_assignment
   * @param int $parentid optional parentid to set
   */
  function create_job($intelli_assignment, $parentid = 0) {
    // Load node if this is an update
    $job = tzintellitime_node_load_by_intellitime_id($intelli_assignment->id);
    $job = $intelli_assignment->convert_to_tzjob($this->account, $job);
    $job->parentid = $parentid;
    return $this->store_node($job);
  }

  /**
   * Does the actual work of storing a node to the drupal database.
   * @param Object $node_data actual node data to save.
   * @return Object Full drupal node object.
   */
  function store_node($node_data) {
    $node = node_submit($node_data);
    node_save($node);

    watchdog('tzintellitime_sync', '!operation !type !nid',
             array(
               '!operation' => (isset($node_data->nid) && $node_data->nid) ? 'Updated' : 'Inserted',
               '!type' => $node->type,
               '!nid' => $node->nid
             ),
             WATCHDOG_NOTICE,
             l('View', 'node/' . $node->nid));

    return $node;
  }
}

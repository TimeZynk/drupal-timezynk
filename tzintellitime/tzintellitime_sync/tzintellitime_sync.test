<?php

/* THESE TESTS CROSS THE BOUNDARY BETWEEN TEST DB AND REAL DB !
 *
 * There is a patch that possibly fixes this problem, until then
 * we have to test manually.
 *
 * For the patch see: http://drupal.org/node/970564
 * For manual test instructions: https://vpn.timezynk.com/wiki/acceptanstest
 */
/*
class TZIntellitimeSyncTestCase extends DrupalWebTestCase {
  public static function getInfo() {
    return array(
      'name' => 'TZIntellitimeSync Test Suite',
      'description' => '',
      'group' => 'TZIntellitimeSync',
    );
  }

  public function setUp() {
    // Enable any modules required for the test.
    parent::setUp('libraries', 'date_api', 'date_timezone', 'tzbase', 'tzintellitime', 'tzintellitime_mock', 'tzintellitime_sync');

    $this->admin_user = $this->drupalCreateUser(array('administer site configuration'));
    $this->drupalLogin($this->admin_user);

    // Use mock intellitime URL
    $post = array('tzintellitime_base_url' => url('IntelliplanWeb/Portal/Login.aspx', array('absolute' => TRUE)));
    $this->drupalPost('admin/settings/timezynk/tzintellitime', $post, t('Save configuration'));

    variable_set('date_default_timezone_name', 'Europe/Stockholm');
    $this->drupalLogout();

    // Include resources
    tzbase_include_proto_classes();
    tzintellitime_include_classes();
    require_once dirname(__FILE__) . '/tzintellitime_sync.class.inc';


    // Create and test user
    $this->account = (object)array('name' => 'test user', 'pass_raw' => 'test password');
    $this->login_timestamp = time();
    $this->drupalLogin($this->account);
    $this->account += user_load(array('name' => $this->account->name));
    $this->assertTrue($this->account, 'account created for ' . $this->account->name);
  }

  public function testIsCorrectlySynchronizedOnFirstLogin() {
    $this->assertTrue($this->login_timestamp <= $this->account->intellitime_last_sync);

    $num_rows = db_result(db_query('SELECT COUNT(*) FROM {tzintellitime_sync}'));
    $this->assertTrue($num_rows);
  }

  public function testCreatingData() {
    $this->controller = new TZIntellitimeSyncController($this->account);
    $this->doTestCreatingJob();
    $this->doTestUpdatingExistingJob();
    $this->doTestCreatingReport();
    $this->doTestUpdatingExistingReport();
    $this->doTestCreateChildJob();
    $this->doTestCreatingReportWithoutJobShallFail();
  }

  public function doTestCreatingJob() {
    $assignment = $this->createAssignment();
    $node = $this->controller->create_job($assignment);
    $this->assertNotNull($node);
    $this->assertTrue($node->nid, "Expected valid drupal ID.");
    $this->assertEqual($assignment->id, $node->intellitime_id, 'Expected same intellitime id.');
    $this->assertEqual($assignment->title, $node->title, 'Expected equal titles');
  }

  public function doTestUpdatingExistingJob() {
    $assignment = $this->createAssignment();
    $nodes[] = $this->controller->create_job($assignment);
    $assignment->title .= '2';
    $nodes[] = $this->controller->create_job($assignment);
    $this->assertEqual($nodes[0]->nid, $nodes[1]->nid, 'Expected same node-id');
    $this->assertEqual($assignment->title, $nodes[1]->title, 'Expected equal titles');
  }

  public function doTestCreateChildJob() {
    $parent_job = $this->createAssignment();
    $parent_node = $this->controller->create_job($parent_job);
    $assignment = $this->createAssignment();
    $node = $this->controller->create_job($assignment, $parent_node->nid);
    $this->assertEqual($parent_node->nid, $node->parentid);
    $this->assertEqual(0, $parent_node->parentid);
  }

  public function doTestCreatingReport() {
    $report = $this->createReport();
    $assignment = $this->createAssignment($report->title);
    $job_node = $this->controller->create_job($assignment);
    $report_node = $this->controller->create_report($report, array($assignment->title => $job_node->nid));
    $this->assertNotNull($report_node);
    $this->assertTrue($report_node->nid);
  }

  public function doTestUpdatingExistingReport() {
    $report = $this->createReport();
    $assignment = $this->createAssignment($report->title);
    $job_node = $this->controller->create_job($assignment);
    $report_node = $this->controller->create_report($report, array($assignment->title => $job_node->nid));

    // Update report and create again
    $report->break_duration_minutes = 35;
    $report_map[$report_node->intellitime_id] = $report_node;
    $report_node2 = $this->controller->create_report($report, array($assignment->title => $job_node->nid), $report_map);

    $this->assertEqual($report_node->nid, $report_node2->nid, 'Expected equal NID after update');
    $this->assertEqual($report->break_duration_minutes*60, $report_node2->breakduration, 'Expected updated breakduration');
  }

  public function doTestCreatingReportWithoutJobShallFail() {
    $report = $this->createReport();
    $report_node = $this->controller->create_report($report);
    $this->assertNull($report_node);
  }

  public function testFullSync() {
    // Add a basic assignment to the mock
    $assignments[] = $this->createAssignment('Test Company, Test Assignment, Test Task');

    // Add a couple booked reports
    $expected_title = 'Test Company, Test Assignment, Test Task';
    $reports = array();
    for($i = 1; $i < 11; $i++) {
      $reports[] = $this->createReport($expected_title, 2010, 11, $i);
    }

    // Post the new data to the mock
    $this->setupMockData($reports, $assignments);

    $before_sync = time();
    $this->assertTrue(tzintellitime_is_authenticated($this->account));
    $this->assertEqual(TZIntellitimeSyncController::SYNC_OK, tzintellitime_sync_synchronize_user($this->account->uid));
    $this->account = user_load($this->account->uid);

    $this->assertTrue($before_sync <= $this->account->intellitime_last_sync);

    // Update one report before checking results to make sure they are independant
    $reports[3]->begin = '00:00';
    $reports[3]->end = '08:00';
    $reports[3]->state = TZIntellitimeReport::STATE_REPORTED;
    $reports[] = $this->createReport($expected_title, 2010, 11, 11);
    $this->setupMockData($reports, $assignments);

    // Check reports
    $result = db_query('SELECT nid FROM {tzreport} ORDER BY begintime ASC');
    $i = 1;
    while($nid = db_result($result)) {
      $report = node_load($nid, NULL, TRUE);
      $this->assertEqual($expected_title, $report->title);
      $this->assertEqual("Report on 2010-11-$i", $report->body);
      $begintime = tzbase_make_date($report->begintime);
      $endtime = tzbase_make_date($report->endtime);
      $this->assertEqual("2010-11-$i 08:00:00", $begintime->format('Y-m-j H:i:s'));
      $this->assertEqual("2010-11-$i 18:00:00", $endtime->format('Y-m-j H:i:s'));
      $this->assertEqual(TZFlags::CREATED, $report->flags);
      $i++;
    }
    $this->assertEqual(11, $i);

    tzintellitime_sync_synchronize_user($this->account->uid);

    // Check reports
    $result = db_query('SELECT nid FROM {tzreport} ORDER BY begintime ASC');
    $i = 1;
    while($nid = db_result($result)) {
      $report = node_load($nid, NULL, TRUE);
      $this->verbose(print_r($report, TRUE));
      $this->assertEqual($expected_title, $report->title);
      $this->assertEqual("Report on 2010-11-$i", $report->body);
      $begintime = tzbase_make_date($report->begintime);
      $endtime = tzbase_make_date($report->endtime);
      if($i == 4) {
        $this->assertEqual("2010-11-$i 00:00:00", $begintime->format('Y-m-j H:i:s'));
        $this->assertEqual("2010-11-$i 08:00:00", $endtime->format('Y-m-j H:i:s'));
        $this->assertEqual(TZFlags::REPORTED, $report->flags);
      } else {
        $this->assertEqual("2010-11-$i 08:00:00", $begintime->format('Y-m-j H:i:s'));
        $this->assertEqual("2010-11-$i 18:00:00", $endtime->format('Y-m-j H:i:s'));
        $this->assertEqual(TZFlags::CREATED, $report->flags);
      }
      $i++;
    }
    $this->assertEqual(12, $i);

  }

  function setupMockData($reports, $assignments) {
    $this->drupalLogin($this->admin_user);
    $post = array(
      'tzintellitime_mock_reports' => serialize($reports),
      'tzintellitime_mock_assignments' => serialize($assignments),
    );
    $this->drupalPost('admin/settings/timezynk/tzintellitime_mock', $post, t('Save configuration'));
    $this->drupalLogin($this->account);
  }

  function createAssignment($title = "A very nice job..") {
    $assignment = new TZIntellitimeAssignment();
    $assignment->id = uniqid('testjob');
    $assignment->title = $title;
    $assignment->report_key = $title;
    return $assignment;
  }

  function createReport($title = "En dag i livet fÃ¶r en apa.", $year = 2010, $month = 9, $day = 1) {
    $report = new TZIntellitimeReport();
    $report->id = uniqid('testreport');
    $report->state = TZIntellitimeReport::STATE_OPEN;
    $report->year = $year;
    $report->month = $month;
    $report->day = $day;
    $report->title = $title;
    $report->begin = "08:00";
    $report->end = "18:00";
    $report->comment = "Report on $year-$month-$day";
    $report->break_duration_minutes = 24;
    return $report;
  }


  protected function assertEqual($first, $second, $message = '', $group = 'Other') {
    if(!$message) {
      $message = 'Expected "' . $first . '", got "' . $second . '"';
    }
    parent::assertEqual($first, $second, $message, $group);
  }
}
*/

class TZIntellitimeSyncUnitTestCase extends DrupalUnitTestCase {
  public static function getInfo() {
    return array(
      'name' => 'TZIntellitimeSync Unit Test Suite',
      'description' => '',
      'group' => 'TZIntellitimeSync',
    );
  }

  public function setUp() {
    require_once dirname(__FILE__) . '/tzintellitime_sync.class.inc';
  }

public function testMatchJobShouldFindNid() {
    $jobmap = array(
      'Axis Commun, Lagerarbeta, Q6032, spec' => 1,
      'Axis Communic, Lagerarbeta, "Heating"' => 2,
      'Axis Communicatio, Lagerarbeta, P553' => 3,
      'Lagerarbetare, TimeZynk' => 4,
    );

    $titles = array(
      'Axis Communication AB, Lagerarbetare, Q6032, spec. prod.',
      'Axis Communication AB, Lagerarbetare, "Heating"',
      'Axis Communicatio, Lagerarbeta, P5534',
      'Lagerarbetare, TimeZynk',
    );
    $count = sizeof($titles);
    for ($i = 0; $i < $count; $i++) {
      $title = $titles[$i];
      $nid = TZIntellitimeSyncController::match_job($jobmap, $title);
      $this->assertEqual($nid, $i+1);
    }
  }

  public function testMatchJobShouldReturnFalse() {
    $jobmap = array(
      'Axis Commun, Lagerarbeta, Q6032, spec' => 1,
      'Axis Communic, Lagerarbeta, "Heating"' => 2,
      'Axis Communicatio, Lagerarbeta, P553' => 3,
      'Lagerarbetare, TimeZynk' => 4,
    );

    $titles = array(
      'Axis CommYnication AB, Lagerarbetare, Q6032, spec. prod.',
      'Axis Communication AB, LagerarbetYre, "Heating"',
      'Axis Communicatio, Lagerarbeta, P55Y4',
      'Lagerarbetar, TimeZyn',
    );
    $count = sizeof($titles);
    for ($i = 0; $i < $count; $i++) {
      $title = $titles[$i];
      $nid = TZIntellitimeSyncController::match_job($jobmap, $title);
      $this->assertFalse($nid, t('Expected titles to not match'));
    }
  }
}
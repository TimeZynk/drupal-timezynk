<?php

define('TZINTELLITIME_BASE_URL', variable_get('tzintellitime_base_url', ''));

/**
 * Implementation of hook_menu().
 */
function tzintellitime_menu() {
  $items = array();
  $items['admin/settings/timezynk/tzintellitime'] = array(
    'title' => 'Intellitime',
    'description' => 'Sitewide settings for the TimeZynk Intellitime bridge.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tzintellitime_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'file' => 'tzintellitime.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implementation of hook_nodeapi. Extend tzjob and tzreport nodes
 * with extra fields needed for mapping them to the corresponding
 * intellitime objects.
 * @param $node node to edit
 * @param $op operation
 * @param $a3 operation argument
 * @param $a4 operation argument
 * @see hook_nodeapi
 */
function tzintellitime_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if($node && ($node->type == 'tzjob' || $node->type == 'tzreport')) {
    switch($op) {
      case 'presave':
        /* By default we assume that we are storing local changes, unless the saving
         * code explicitly sets intellitime_synchronized to TRUE */
        if(!empty($node->intellitime_id)) {
          if(empty($node->intellitime_synchronized)) {
            $node->intellitime_local_changes = 1;
          } else {
            $node->intellitime_local_changes = 0;
          }
        }
        break;

      case 'delete':
        db_query('DELETE FROM {tzintellitime} WHERE nid = %d', $node->nid);
        break;

      case 'delete revision':
        db_query('DELETE FROM {tzintellitime} WHERE vid = %d', $node->vid);
        break;

      case 'insert':
        if(isset($node->intellitime_id) && $node->intellitime_id) {
          drupal_write_record('tzintellitime', $node);
        }
        break;

      case 'load':
        return db_fetch_array(db_query('SELECT * FROM {tzintellitime} WHERE vid = %d', $node->vid));
        break;

      case 'update':
        if(isset($node->intellitime_id) && $node->intellitime_id) {
          if(!empty($node->revision)) {
            // new revision, treat as insert
            drupal_write_record('tzintellitime', $node);
          } else {
            // update of previous revision
            drupal_write_record('tzintellitime', $node, 'vid');
          }
        }
        break;
    }
  }
}


/**
 * Implements hook_form_alter(). A very important function in this file,
 * It:
 * - inserts our own authentication hook into all login forms.
 * - adds intellitime id to the node form
 */
function tzintellitime_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'user_login' || $form_id == 'user_login_block') {
    if (isset($form['#validate']) && is_array($form['#validate'])) {
      $validate_key = array_search('user_login_authenticate_validate', $form['#validate']);
      if($validate_key !== FALSE) {
        // replace standard authentication function
        $form['#validate'][$validate_key] = 'tzintellitime_login_authenticate_validate';
      } else {
        // standard function deactivated by other module, insert ourselves next-last
        $final_validator = array_pop($form['#validate']);
        $form['#validate'][] = 'tzintellitime_login_authenticate_validate';
        $form['#validate'][] = $final_validator;
      }
    }
  } else if($form_id == 'tzreport_node_form') {
    $node = $form['#node'];
    $form['intellitime_id'] = array(
      '#type' => 'value',
      '#value' => isset($node->intellitime_id) ? $node->intellitime_id : 'not set',
    );
  }
}

/**
 * Authenticate a user towards intellitime
 * @param Array $form
 * @param Array $form_state
 */
function tzintellitime_login_authenticate_validate($form, &$form_state) {
  global $user;

  if(!empty($user->uid)) {
    // Another module has already handled authentication
    return;
  }

  $username = $form_state['values']['name'];
  $password = $form_state['values']['pass'];

  // Check for valid user name
  user_login_name_validate($form, $form_state);

  // Load the user if it is exists and is not blocked
  $account = user_load(array('name' => $username, 'status' => 1));

  // Any errors so far?
  if(form_get_errors()) {
    return;
  }

  if (!$account || (isset($account->intellitime_user) && !tzintellitime_is_authenticated($account))) {
    try {
      if(tzintellitime_server_auth($account, $username, $password)) {
        // Login successful, store in global user object
        $user = $account;

        // Schedule for sync
        if(module_exists('tzintellitime_sync')) {
          tzintellitime_sync_schedule_user($user->uid);
        }
      }
    } catch(TZNetworkFailureException $e) {
      watchdog('tzintellitime', 'Network problem when authenticating @user: @msg',
        array('@user' => $username, '@msg' => $e->getMessage()),
        WATCHDOG_WARNING);
    } catch(TZAuthenticationFailureException $e) {
      watchdog('tzintellitime', 'Failed to authenticate @user',
        array('@user' => $username),
        WATCHDOG_WARNING);
    }
  }

  // Fallback to password authentication
  if(empty($user->uid)) {
    user_authenticate($form_state['values']);
  }
}

/**
 * Validate username and password against Intellitime Server
 */
function tzintellitime_server_auth(&$account, $username, $password) {

  // new user or existing user with expired cookie-jar.
  if(isset($account->intellitime_session_data)) {
    TZIntellitimeBot::destroy_session_data($account->intellitime_session_data);
  }

  $bot = new TZIntellitimeBot(TZINTELLITIME_BASE_URL);
  if(!$bot->login($username, $password)) {
    TZIntellitimeBot::destroy_session_data($bot->get_session_data());
    return FALSE;
  }

  $user_data = array(
    'intellitime_user' => TRUE,
    'intellitime_session_data' => $bot->get_session_data(),
  );

  if (!$account) {
    $user_data['mail'] = $username;
    $user_data['init'] = $username;
    $user_data['name'] = $username;
    $user_data['pass'] = $password;
    $user_data['status'] = 1;
  }

  $account = user_save($account, $user_data);
  unset($bot); // flushes the cookiejar used by sync..

  return TRUE;
}


/**
 * Load a node by searching for the intellitime ID
 * @param string $intellitime_id
 * @return Node if intellitime ID was found, otherwise NULL
 */
function tzintellitime_node_load_by_intellitime_id($intellitime_id) {
  return node_load(db_result(db_query("SELECT nid FROM {tzintellitime} WHERE intellitime_id = '%s' ORDER BY vid DESC LIMIT 1", $intellitime_id)), NULL, TRUE);
}

/**
 *
 * Private function to check if an account that has already
 * been verified to be an intellitime account has valid authentication.
 * @param unknown_type $account
 */
function tzintellitime_is_authenticated($account) {
  return ($account && $account->intellitime_user &&
    isset($account->intellitime_session_data) &&
    TZIntellitimeBot::is_valid_session_data($account->intellitime_session_data)
  );
}